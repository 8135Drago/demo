import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.xssf.eventusermodel.XSSFReader;
import org.apache.poi.xssf.model.SharedStringsTable;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

class ABCData {
    private String field1;
    private String field2;
    private String field3;
    private String field4;
    private String field5;
    
    public ABCData(String field1, String field2, String field3, String field4, String field5) {
        this.field1 = field1;
        this.field2 = field2;
        this.field3 = field3;
        this.field4 = field4;
        this.field5 = field5;
    }
    
    public String getField1() { return field1; }
    public String getField2() { return field2; }
    public String getField3() { return field3; }
    public String getField4() { return field4; }
    public String getField5() { return field5; }
}

class ABCSheetHandler extends DefaultHandler {
    private SharedStringsTable sst;
    private String lastContents;
    private boolean nextIsString;
    private List<String> currentRow = new ArrayList<>();
    private List<ABCData> currentChunk = new ArrayList<>();
    private boolean isFirstRow = true;
    private String currentCellRef;
    private int currentCol = 0;
    private int chunkSize;
    private int totalRowsProcessed = 0;
    private String additionalParam;
    private TestProcess testProcess;
    
    public ABCSheetHandler(SharedStringsTable sst, int chunkSize, String additionalParam, TestProcess testProcess) {
        this.sst = sst;
        this.chunkSize = chunkSize;
        this.additionalParam = additionalParam;
        this.testProcess = testProcess;
    }
    
    @Override
    public void startElement(String uri, String localName, String name, Attributes attributes) {
        if (name.equals("c")) {
            String cellType = attributes.getValue("t");
            nextIsString = cellType != null && cellType.equals("s");
            currentCellRef = attributes.getValue("r");
            if (currentCellRef != null) {
                currentCol = getColumnIndex(currentCellRef);
            }
        }
        lastContents = "";
    }
    
    @Override
    public void endElement(String uri, String localName, String name) {
        if (nextIsString) {
            try {
                int idx = Integer.parseInt(lastContents);
                lastContents = sst.getItemAt(idx).getString();
            } catch (Exception e) {
                lastContents = "";
            }
        }
        
        if (name.equals("v") || name.equals("t")) {
            while (currentRow.size() < currentCol) {
                currentRow.add("");
            }
            currentRow.add(lastContents);
        } else if (name.equals("row")) {
            if (isFirstRow) {
                isFirstRow = false;
            } else if (!currentRow.isEmpty()) {
                ABCData data = createABCData(currentRow);
                currentChunk.add(data);
                totalRowsProcessed++;
                
                if (currentChunk.size() >= chunkSize) {
                    testProcess.test(new ArrayList<>(currentChunk), additionalParam);
                    currentChunk.clear();
                }
            }
            currentRow.clear();
            currentCol = 0;
        }
    }
    
    @Override
    public void characters(char[] ch, int start, int length) {
        lastContents += new String(ch, start, length);
    }
    
    private int getColumnIndex(String cellRef) {
        StringBuilder colString = new StringBuilder();
        for (char c : cellRef.toCharArray()) {
            if (Character.isLetter(c)) {
                colString.append(c);
            } else {
                break;
            }
        }
        int index = 0;
        for (int i = 0; i < colString.length(); i++) {
            index = index * 26 + (colString.charAt(i) - 'A' + 1);
        }
        return index - 1;
    }
    
    private ABCData createABCData(List<String> row) {
        String f1 = row.size() > 0 ? row.get(0) : "";
        String f2 = row.size() > 1 ? row.get(1) : "";
        String f3 = row.size() > 2 ? row.get(2) : "";
        String f4 = row.size() > 3 ? row.get(3) : "";
        String f5 = row.size() > 4 ? row.get(4) : "";
        return new ABCData(f1, f2, f3, f4, f5);
    }
    
    public void processRemainingChunk() {
        if (!currentChunk.isEmpty()) {
            testProcess.test(new ArrayList<>(currentChunk), additionalParam);
            currentChunk.clear();
        }
    }
    
    public int getTotalRowsProcessed() {
        return totalRowsProcessed;
    }
}

interface TestProcess {
    void test(List<ABCData> dataList, String param);
}

public class ExcelABCReader {
    
    public static int readAndProcess(String filePath, String sheetName, int chunkSize, 
                                      String additionalParam, TestProcess testProcess) throws Exception {
        
        OPCPackage pkg = OPCPackage.open(filePath);
        XSSFReader reader = new XSSFReader(pkg);
        SharedStringsTable sst = reader.getSharedStringsTable();
        
        InputStream sheetStream = findSheetStream(reader, sheetName);
        if (sheetStream == null) {
            pkg.close();
            throw new IllegalArgumentException("Sheet '" + sheetName + "' not found!");
        }
        
        InputSource sheetSource = new InputSource(sheetStream);
        SAXParserFactory saxFactory = SAXParserFactory.newInstance();
        SAXParser saxParser = saxFactory.newSAXParser();
        XMLReader xmlReader = saxParser.getXMLReader();
        
        ABCSheetHandler handler = new ABCSheetHandler(sst, chunkSize, additionalParam, testProcess);
        xmlReader.setContentHandler(handler);
        xmlReader.parse(sheetSource);
        
        handler.processRemainingChunk();
        
        sheetStream.close();
        pkg.close();
        
        return handler.getTotalRowsProcessed();
    }
    
    private static InputStream findSheetStream(XSSFReader reader, String sheetName) throws Exception {
        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) reader.getSheetsData();
        while (iter.hasNext()) {
            InputStream stream = iter.next();
            String name = iter.getSheetName();
            if (name.equals(sheetName)) {
                return stream;
            }
            stream.close();
        }
        return null;
    }
}